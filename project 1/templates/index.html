<!DOCTYPE html>
<html>
<head>
	<title>Project 1</title>
  	<link href="stylesheets/d3.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="d3/d3.min.js"></script>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">

	<!-- Optional theme -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">

	<!-- Latest compiled and minified JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>

</head>

<body>
	<div class="navbar navbar-default">
			<h3 class="navbar-header" style = "margin-left: 20px">Project 1: ISIS twitter network analysis</h3>
	</div>

	<div class="container">
    <div id="tooltip" class="hidden">
      <p><strong>Twitter id: </strong><span id="tweeter">100</span></p>
      <p><strong>Follower amount: </strong><span id="follower">100</span></p>
      <p><strong>Following amount: </strong><span id="following">100</span></p>
      <p><strong>Most recent tweet: </strong><span id="tweet">100</span></p>
    </div>
    <h4>Following/Follower count chart </h4>
    <p> The size of each circle represents the total follower and following amount while the inner circle represents the following amount. Circles with a <span style="color:red">red</span> outline were suspended in March, 2015.</p>
    <p>It seems that the amount of followers one has is not a good indicator of it being a part of the ISIS propaganda network. Rather, the ratio of follower/following amount might be a better indicator, as seen the majority of the suspended accounts have a relatively large inner circle in the plot. Hence, the ratio should be considered if we want to predict accounts that will be radicalized in the future. </p>
    <div class="row marketing" style="margin-top: 50px">
      <div class="col-lg-8" id = "graph1"></div>
      <div class="col-lg-4" id = "legend_space">
        </div>
      </div>
      <h4>Hierarchical Bundle Chart</h4>
    <p> This has serious runtime issues. Consider either reducing the edge size or abandon this chart completely. <span style= "color:green">Green</span> line means in degree and <span style="color:red">Red</span> line means out degree.</p>
      <div class="row marketing" style="margin-top: 50px">
        <div class="col-lg-8" id = "graph2"></div>
        <div class="col-lg-4" id = "legend_bundle"></div>
      </div>
  </div>
		<script>

var width = 800,
    height =800,
    n = 500,
    visible = false,
    active_node = '';

var color = d3.scale.ordinal().range(["#43a2ca", "#a8ddb5"]);
var color_bundle = d3.scale.ordinal().range(["#43a2ca", "#a8ddb5"]);
color.domain(["Follower", "Following"]);
color_bundle.domain(["Being followed", "Following others"])

//----------------------------LEGEND------------------------------
var legendRectSize = 18;
var legendSpacing = 4;

var svg_legend = d3.select("#legend_space").append("svg")
      .attr("width", 300)
      .attr("height", 100);

var sub_legend = svg_legend.selectAll('.legend')
  .data(color.domain())
  .enter()
  .append('g')
  .attr('class', 'legend')
  .attr('transform', function(d, i) {
    var height = legendRectSize + 2 * legendSpacing;
    var width = 150;
    var offset =  height * color.length / 2;
    var horz = 2 * legendRectSize;
    var vert = i * height + 2;
    return 'translate(' + horz + ',' + vert + ')';
  });
  
  sub_legend.append('rect')
  .attr('width', legendRectSize)
  .attr('height', legendRectSize)
  .style('fill', color)
  .style('stroke', color);

  sub_legend.append('text')
  .attr('x', legendRectSize + 2 * legendSpacing)
  .attr('y', legendRectSize - legendSpacing)
  .text(function(d) { return d; });

//----------------------LEGEND FOR BUNDLE ----------------
var svg_legend_bundle = d3.select("#legend_bundle").append("svg")
      .attr("width", 300)
      .attr("height", 100);

var sub_legend_bundle = svg_legend_bundle.selectAll('.legend')
  .data(color_bundle.domain())
  .enter()
  .append('g')
  .attr('class', 'legend')
  .attr('transform', function(d, i) {
    var height = legendRectSize + 2 * legendSpacing;
    var width = 150;
    var offset =  height * color.length / 2;
    var horz = 2 * legendRectSize;
    var vert = i * height + 2;
    return 'translate(' + horz + ',' + vert + ')';
  });
  
  sub_legend_bundle.append('rect')
  .attr('width', legendRectSize)
  .attr('height', legendRectSize)
  .style('fill', color)
  .style('stroke', color);

  sub_legend_bundle.append('text')
  .attr('x', legendRectSize + 2 * legendSpacing)
  .attr('y', legendRectSize - legendSpacing)
  .text(function(d) { return d; });
//---------------------END LEGEND---------------------------

//--------------------BUNDLE SETUP--------------------------
var diameter = 800,
    radius = diameter / 2,
    innerRadius = radius - 150;

var cluster = d3.layout.cluster()
    .size([360, innerRadius])
    .sort(null)
    .value(function(d) { return d.size; });

var bundle = d3.layout.bundle();

var line = d3.svg.line.radial()
    .interpolate("bundle")
    .tension(0.85)
    .radius(function(d) { return d.y; })
    .angle(function(d) { return d.x / 180 * Math.PI; });


var svg_bundle = d3.select("#graph2").append("svg")
    .attr("width", diameter)
    .attr("height", diameter)
  .append("g")
    .attr("transform", "translate(" + radius + "," + radius + ")");

var link_bundle = svg_bundle.append("g").selectAll(".link_bundle"),
    node_bundle = svg_bundle.append("g").selectAll(".node_bundle");

//------------------ END BUNDLE SETUP --------------------------

//---------------- BUBBLE CHART SETUP ---------------------------
var force = d3.layout.force()
    .charge(function(d, i) { return i ? -1: -100; })
    .gravity(0.1)
    // .linkDistance(100)
    .size([width, height]);

var pie = d3.layout.pie().value(function(d){return d;})
.sort(function (a, b) {return b - a;});

var svg = d3.select("#graph1").append("svg")
    .attr("width", width)
    .attr("height", height);
//---------------- END BUBBLE CHART SETUP -------------------------

d3.json("data/d3data-100.json", function(error, graph) {
  var new_nodes = convert(graph.nodes)[0],
    highFF_nodes = convert(graph.nodes)[1];
  var nodes = cluster.nodes(packageHierarchy(graph.nodes)),
    links = packageImports(nodes, graph.links);

  var loading = svg_bundle.append("text")
    .attr("x", width / 2)
    .attr("y", height / 2)
    .attr("dy", ".35em")
    .style("text-anchor", "middle")
    .text("Simulating. One moment pleaseâ€¦");


//------------------ BUNDLE CHART ----------------------
  link_bundle = link_bundle
    .data(bundle(links))
  .enter().append("path")
    .each(function(d) { d.source = d[0], d.target = d[d.length - 1]; })
    .attr("class", "link_bundle")
    .attr("d", line);

  node_bundle = node_bundle
    .data(nodes.filter(function(n) { return !n.children; }))
    .enter().append("text")
    .attr("class", "node_bundle")
    .attr("dy", ".1em")
    .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" + (d.x < 180 ? "" : "rotate(180)"); })
    .style("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
    .text(function(d, i) {return d.userName;})
    .style("fill", function(d) {
      if (d.suspended == true) {
        return "#de2d26";
      } else {
        return "#bbb";
      }
    })
    .on("mouseover", mouseovered)
    .on("mouseout", mouseouted);

    loading.remove();

function mouseovered(d) {
  node_bundle
      .each(function(n) { n.target = n.source = false; });

  link_bundle
      .classed("link--target", function(l) { 
        console.log(l.target);
        if (l.target === d) return l.source.source = true; })
      .classed("link--source", function(l) { if (l.source === d) return l.target.target = true; })
    .filter(function(l) { return l.target === d || l.source === d; })
      .each(function() { this.parentNode.appendChild(this); });

}

function mouseouted(d) {
  link_bundle
      .classed("link--target", false)
      .classed("link--source", false);
}

d3.select(self.frameElement).style("height", diameter + "px");

var count = 0;
// Lazily construct the package hierarchy from class names.
function packageHierarchy(classes) {
  var map = {};
  function find(name, data) {
    var node = map[name];
    if (!node) {
      node = map[name] = data || {name: name, children: []};
      if (name){
          node.parent = find("");
          node.parent.children.push(node);
          node.key = name;
        } 
    } 
    return node;
  }

  classes.forEach(function(d) {
    find(d.userId, d);
  });
  return map[""];
}

// Return a list of imports for the given array of nodes.
function packageImports(nodes, links) {
  var map = {},
      imports = [];

  // Compute a map from name to node.
  nodes.forEach(function(d) {
    map[d.userName] = d;
  });

  // For each import, construct a link from the source to target node.
  links.forEach(function(d) {
    var s = d.source,
      t = d.target;

    imports.push({source: nodes[s], target: nodes[t]});
    });
  return imports;
}
//---------- LIST NODES with high following/follower ratio-------
document.getElementById("highFFR").innerHTML = highFF_nodes;


//------------------- BUBBLE CHART ---------------------
  force
      .nodes(new_nodes)
      // .links(graph.links)
      .start();

  var root = new_nodes[0];
  root.fixed = true;

  var node = svg.selectAll(".node")
      .data(new_nodes)
      .enter().append("circle")
      .attr("class", "node")
      .attr("r", function(d) { return d.r; })
      .style("fill", function(d) { return color(0); })
      .style("stroke", function(d) {
        if (d.suspended == true){
          return "#de2d26";
        }
      })
      // .call(node_drag)
      .on("click", function(d) { display_tip(d); });

  var innerC = svg.selectAll("svg")
      .data(new_nodes)
    .enter().append("circle")
      .attr("class", "inner_node")
      .attr("r", function(d) { 
        var ratio = d.followingCount/d.followersCount;
        var innerR = d.r*(ratio/(1+ratio));
        return innerR; })
      .style("fill", function(d) { return color(1); })
      .on("click", function(d) { display_tip(d); });

  function display_tip(d){
        var xPos = d3.event.pageX;
        var yPos = d3.event.pageY;

        d3.select("#tooltip")
          .style("left", xPos +"px")
          .style("top", yPos + "px")
          .select("#tweeter")
          .text(d.userName);

        d3.select("#tooltip")
          .select("#follower")
          .text(d.followersCount);

        d3.select("#tooltip")
          .select("#following")
          .text(d.followingCount);

        d3.select("#tooltip")
          .select("#tweet")
          .text(d.tweets);

        /*--- if clicked node is different from the one previously, reopen tooltip for the new node by setting visible to false --- */
        if (active_node != d.userName){
          visible = false;
        }
        active_node = d.userName;

        /*--- toggle tooltip ---*/
        if (visible == false){
          d3.select("#tooltip").classed("hidden", false)
          visible = true;
        } else {
          d3.select("#tooltip").classed("hidden", true)
          visible = false;
        }
  }

  function tick(){
    var node_x = 0;
    var node_y = 0;
    node.attr("cx", function(d) { node_x = d.x; return d.x; })
        .attr("cy", function(d) { node_y = d.y;return d.y; });
    innerC.attr("cx", function(d) { node_x = d.x; return d.x; })
        .attr("cy", function(d) { node_y = d.y;return d.y; });
  };

  loading.remove();

 force.on("tick", function ticky(e){
  var q = d3.geom.quadtree(new_nodes),
      i = 0,
      n = new_nodes.length;
  while (++i < n) q.visit(collide(new_nodes[i]));
  
  tick();
 });

 function convert(node_list){
  var result = [];
  var highFF = []
  var current_node = {};

  count = 0;

  while (++count<node_list.length){
      //----- for bubble chart ------
      current_node = node_list[count];
      current_node.r = 
      Math.sqrt(Math.sqrt((current_node.followersCount+current_node.followersCount)/10000));
      // var followingR = current_node.followingCount/(current_node.followersCount+current_node.followingCount);
      var followingR = current_node.followingCount/current_node.followersCount;
      // var followerR = 1 - followingR;
      // current_node.FFratio = [followingR, followerR];
      result.push(current_node);

      //------ for high following/follower ratio----
      if (followingR > 0.6){
        highFF.push(current_node.userName);
      }
  };
  return [result, highFF];
 };

 function collide(node) {
  var node_r = node.r,
      r = node_r + 100,
      nx1 = node.x - r,
      nx2 = node.x + r,
      ny1 = node.y - r,
      ny2 = node.y + r;
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node_r + quad.point.r;
      if (l < r) {
        l = (l - r) / l * .5;
        node.x -= x *= l;
        node.y -= y *= l;
        quad.point.x += x;
        quad.point.y += y;
      }
    }
    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
  };
};
//----------------- END BUBBLE CHART -----------------

});



d3.json("data/d3data-100.json", function(error, classes) {


});

    </script>
</body>
</html>